<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Space Runner - Alienes.me</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Outfit', sans-serif;
            background: #000;
            user-select: none;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        #score {
            color: #fff;
            font-size: 2.5rem;
            font-weight: 800;
            text-shadow: 0 0 15px #0ff;
            letter-spacing: 2px;
        }

        #game-over,
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        #game-over {
            display: none;
        }

        .btn {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            border: none;
            padding: 15px 50px;
            color: #000;
            font-weight: 900;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 30px;
            transition: all 0.2s;
            text-transform: uppercase;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
        }

        .key {
            display: inline-block;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 5px 12px;
            border-radius: 8px;
            margin: 0 5px;
            background: rgba(255, 255, 255, 0.1);
            font-weight: bold;
            color: #0ff;
        }
    </style>
</head>

<body>
    <div id="ui-container">
        <div id="score">0</div>
        <div class="text-white/50 text-sm">
            <a href="/" class="hover:text-white transition-colors pointer-events-auto font-bold">← ÇIKIŞ</a>
        </div>
    </div>

    <div id="start-screen">
        <h1
            class="text-7xl md:text-9xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-600 mb-4 filter drop-shadow-[0_0_15px_rgba(0,255,255,0.5)]">
            NEON RUNNER</h1>
        <p class="text-cyan-100 mb-12 text-2xl tracking-widest font-light">HYPERSPEED EDITION</p>
        <div class="text-gray-400 mb-12 flex gap-8 text-lg">
            <div><span class="key">←</span> / <span class="key">A</span> SOL</div>
            <div><span class="key">→</span> / <span class="key">D</span> SAĞ</div>
        </div>
        <button class="btn" onclick="startGame()">UÇUŞA BAŞLA</button>
    </div>

    <div id="game-over">
        <h2 class="text-6xl font-black text-white mb-4">ÇARPIŞMA!</h2>
        <p class="text-cyan-300 text-3xl mb-8">SKOR: <span id="final-score" class="text-white font-bold">0</span></p>
        <button class="btn" onclick="resetGame()">TEKRAR DENE</button>
        <a href="/" class="inline-block mt-8 text-gray-500 hover:text-white text-sm transition-colors">ANA MENÜYE
            DÖN</a>
    </div>

    <script>
        // Engine Variables
        let scene, camera, renderer;
        let player, jetGroup;
        let obstacles = [];
        let particles = [];
        let trailParticles = [];
        let score = 0;
        let gameSpeed = 0.4;
        let isPlaying = false;
        let animationId;
        let floor;

        // Input State
        const keys = { left: false, right: false };
        let targetX = 0;

        // Constants
        const NEON_BLUE = 0x00ffff;
        const NEON_PINK = 0xff00ff;
        const DARK_BLUE = 0x001133;

        // Audio Engine
        const Audio = {
            ctx: null,
            init() {
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                } catch (e) { console.warn('Web Audio API not supported'); }
            },
            playTone(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            collect() { this.playTone(800, 'sine', 0.1, 0.1); setTimeout(() => this.playTone(1200, 'sine', 0.2, 0.1), 50); },
            crash() {
                this.playTone(100, 'sawtooth', 0.5, 0.3);
                this.playTone(50, 'square', 0.8, 0.3);
            },
            engine() {
                // Simple engine hum loop simulation
                if (!this.ctx) return;
                // In a real game, we'd use a looped buffer or noise node, 
                // but for simple synthesis, we'll skip continuous loops to avoid annoyance 
                // or just play a low drone if user interaction started.
            }
        };

        function init() {
            // Audio.init() removed from here
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000510, 0.03);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 4, 8);
            camera.lookAt(0, 0, -10);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 0);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Point light on player for glow
            const playerLight = new THREE.PointLight(NEON_BLUE, 1, 20);
            playerLight.position.set(0, 2, 0);
            scene.add(playerLight);

            createEnvironment();
            createPlayerJet();

            // Event Listeners
            document.addEventListener('keydown', (e) => onKey(e, true));
            document.addEventListener('keyup', (e) => onKey(e, false));
            window.addEventListener('resize', onWindowResize);

            // Touch
            document.addEventListener('touchstart', handleTouch);
            document.addEventListener('touchend', () => { keys.left = false; keys.right = false; });

            renderer.render(scene, camera);
        }

        function createEnvironment() {
            // Infinite Floor Grid
            const gridHelper = new THREE.GridHelper(400, 100, NEON_BLUE, 0x111122);
            gridHelper.position.y = -2;
            gridHelper.position.z = -100;
            scene.add(gridHelper);

            // Moving Floor Plane (Reflection)
            const planeGeometry = new THREE.PlaneGeometry(400, 400);
            const planeMaterial = new THREE.MeshPhongMaterial({
                color: 0x000510,
                shininess: 50,
                specular: 0x222222
            });
            floor = new THREE.Mesh(planeGeometry, planeMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -2.1;
            scene.add(floor);
        }

        function createPlayerJet() {
            jetGroup = new THREE.Group();

            // Materials
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xcccccc, shininess: 100 });
            const glassMat = new THREE.MeshPhongMaterial({ color: 0x00aaff, shininess: 200, opacity: 0.7, transparent: true });
            const engineMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });

            // Fuselage
            const fuselageGeo = new THREE.ConeGeometry(0.5, 3, 8);
            const fuselage = new THREE.Mesh(fuselageGeo, bodyMat);
            fuselage.rotation.x = -Math.PI / 2;
            jetGroup.add(fuselage);

            // Cockpit
            const cockpitGeo = new THREE.CapsuleGeometry(0.3, 0.8, 4, 8);
            const cockpit = new THREE.Mesh(cockpitGeo, glassMat);
            cockpit.rotation.x = -Math.PI / 2;
            cockpit.position.set(0, 0.3, -0.2);
            jetGroup.add(cockpit);

            // Wings
            const wingGeo = new THREE.BoxGeometry(3, 0.1, 1.5);
            const wings = new THREE.Mesh(wingGeo, bodyMat);
            wings.position.set(0, 0, 0.2);

            // Wing tips (vertical)
            const tipGeo = new THREE.BoxGeometry(0.1, 0.5, 1);
            const leftTip = new THREE.Mesh(tipGeo, engineMat);
            leftTip.position.set(-1.5, 0.2, 0.2);
            const rightTip = new THREE.Mesh(tipGeo, engineMat);
            rightTip.position.set(1.5, 0.2, 0.2);

            jetGroup.add(wings);
            jetGroup.add(leftTip);
            jetGroup.add(rightTip);

            // Engines
            const engineGeo = new THREE.CylinderGeometry(0.2, 0.1, 1, 8);
            const leftEngine = new THREE.Mesh(engineGeo, bodyMat);
            leftEngine.rotation.x = -Math.PI / 2;
            leftEngine.position.set(-0.8, 0, 1);
            const rightEngine = new THREE.Mesh(engineGeo, bodyMat);
            rightEngine.rotation.x = -Math.PI / 2;
            rightEngine.position.set(0.8, 0, 1);

            // Engine Glow
            const glowGeo = new THREE.SphereGeometry(0.25);
            const leftGlow = new THREE.Mesh(glowGeo, engineMat);
            leftGlow.position.set(-0.8, 0, 1.5);
            const rightGlow = new THREE.Mesh(glowGeo, engineMat);
            rightGlow.position.set(0.8, 0, 1.5);

            jetGroup.add(leftEngine);
            jetGroup.add(rightEngine);
            jetGroup.add(leftGlow);
            jetGroup.add(rightGlow);

            scene.add(jetGroup);
            player = jetGroup;
        }

        function onKey(event, isDown) {
            const k = event.key.toLowerCase();
            if (k === 'arrowleft' || k === 'a') keys.left = isDown;
            if (k === 'arrowright' || k === 'd') keys.right = isDown;
        }

        function handleTouch(e) {
            const touchX = e.touches[0].clientX;
            if (touchX < window.innerWidth / 2) { keys.left = true; keys.right = false; }
            else { keys.right = true; keys.left = false; }
        }

        function createObstacle() {
            // Random Shape: Box or Octahedron
            let geometry;
            if (Math.random() > 0.5) geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            else geometry = new THREE.OctahedronGeometry(1);

            const material = new THREE.MeshPhongMaterial({
                color: Math.random() > 0.5 ? NEON_PINK : 0xff0055,
                emissive: 0x440022,
                shininess: 50
            });

            const obstacle = new THREE.Mesh(geometry, material);
            obstacle.position.x = (Math.random() * 14) - 7;
            obstacle.position.y = 0;
            obstacle.position.z = -100;
            obstacle.castShadow = true;

            // Wireframe glow
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff }));
            obstacle.add(line);

            // Rotation speed
            obstacle.userData = {
                rotX: Math.random() * 0.1,
                rotY: Math.random() * 0.1
            };

            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        function createTrail() {
            // Create particles behind engines
            const positions = [[-0.8, 0, 1.5], [0.8, 0, 1.5]];

            positions.forEach(pos => {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.5);
                const mat = new THREE.MeshBasicMaterial({ color: NEON_BLUE, transparent: true, opacity: 0.8 });
                const p = new THREE.Mesh(geo, mat);

                // Add player position offset
                p.position.set(
                    player.position.x + pos[0],
                    player.position.y + pos[1],
                    player.position.z + pos[2]
                );

                scene.add(p);
                trailParticles.push(p);
            });
        }

        function createStarParticles() {
            for (let i = 0; i < 3; i++) {
                const geo = new THREE.BoxGeometry(0.05, 0.05, 3); // Long streaks
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
                const p = new THREE.Mesh(geo, mat);
                p.position.set((Math.random() * 60) - 30, (Math.random() * 30) - 10, -100);
                scene.add(p);
                particles.push(p);
            }
        }

        function update() {
            if (!isPlaying) return;

            // Player Movement (Smooth Lerp)
            if (keys.left && targetX > -7) targetX -= 0.5;
            if (keys.right && targetX < 7) targetX += 0.5;

            player.position.x += (targetX - player.position.x) * 0.1;

            // Banking Animation (Roll)
            const bankAngle = (player.position.x - targetX) * 0.5;
            player.rotation.z = bankAngle;
            player.rotation.x = bankAngle * 0.2; // Slight pitch up/down

            // Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].position.z += gameSpeed;
                obstacles[i].rotation.x += obstacles[i].userData.rotX;
                obstacles[i].rotation.y += obstacles[i].userData.rotY;

                // Collision (Simple Box)
                const dx = Math.abs(player.position.x - obstacles[i].position.x);
                const dz = Math.abs(player.position.z - obstacles[i].position.z);

                if (dx < 1.2 && dz < 1) { Audio.crash(); gameOver(); }

                if (obstacles[i].position.z > 10) {
                    scene.remove(obstacles[i]);
                    obstacles.splice(i, 1);
                    score += 10;
                    document.getElementById('score').innerText = score;
                    Audio.collect();
                    // Progressive Speed Increase
                    gameSpeed += 0.0005;
                }
            }

            // Trail Particles
            createTrail();
            for (let i = trailParticles.length - 1; i >= 0; i--) {
                trailParticles[i].position.z += gameSpeed * 0.5; // Move slower than jet
                trailParticles[i].material.opacity -= 0.05;
                trailParticles[i].scale.z += 0.2;
                if (trailParticles[i].material.opacity <= 0) {
                    scene.remove(trailParticles[i]);
                    trailParticles.splice(i, 1);
                }
            }

            // Star Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].position.z += gameSpeed * 2;
                if (particles[i].position.z > 10) {
                    scene.remove(particles[i]);
                    particles.splice(i, 1);
                }
            }

            // Dynamic Spawning based on score/speed
            const spawnRate = 0.02 + (score * 0.00005);
            if (Math.random() < spawnRate) createObstacle();
            if (Math.random() < 0.3) createStarParticles();

            // Camera Follow
            camera.position.x += (player.position.x * 0.4 - camera.position.x) * 0.1;
            camera.lookAt(player.position.x * 0.2, 0, -20);

            renderer.render(scene, camera);
            animationId = requestAnimationFrame(update);
        }

        function startGame() {
            Audio.init();
            if (Audio.ctx && Audio.ctx.state === 'suspended') Audio.ctx.resume();

            isPlaying = true;
            document.getElementById('start-screen').style.display = 'none';
            update();
        }

        function gameOver() {
            isPlaying = false;
            cancelAnimationFrame(animationId);
            document.getElementById('game-over').style.display = 'flex';
            document.getElementById('final-score').innerText = score;
        }

        function resetGame() {
            score = 0;
            gameSpeed = 0.4;
            targetX = 0;
            document.getElementById('score').innerText = '0';
            document.getElementById('game-over').style.display = 'none';

            obstacles.forEach(o => scene.remove(o)); obstacles = [];
            particles.forEach(p => scene.remove(p)); particles = [];
            trailParticles.forEach(p => scene.remove(p)); trailParticles = [];

            player.position.set(0, 0, 0);
            player.rotation.set(0, 0, 0);

            startGame();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>

</html>